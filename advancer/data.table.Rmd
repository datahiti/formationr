---
title: "Advanced R"
author: "Hubert LEVIEL"
date: "22/09/2025"
output: ioslides_presentation
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)
```

# Exercices dplyr et data.table

```{r echo = TRUE}
library(dplyr)
library(data.table)
```

## Data
```{r echo = TRUE}
library(nycflights13)

data(flights)
data(airports)
data(airlines)
dt_flights <- as.data.table(flights)
dt_airports <- as.data.table(airports)
dt_airlines <- as.data.table(airlines)
```

## A1 - select
La première colonne de la table airports
```{r}
dt_airports[,1]
```

## A2 - select
La colonne name de la table airports
```{r}
select(airports, name)
dt_airports[,"name"]
```

## A3 - select
Les colonnes lat, lon et alt de la table airports
```{r}
select(airports, lat, lon, alt )

dt_airports[,.(lat, lon, alt)]
```


## A4 - select
Toutes les colonnes de la table airports sauf les colonnes lat, lon et alt
```{r}
select(airports, -lat, -lon, -alt )
dt_airports[, -c("lat", "lon", "alt" )]
```

## A5 - select
Les colonnes de la table flights dont le nom commence par "dep_"
```{r}
select(flights, starts_with("dep_"))
dt_flights[,.SD, .SDcols = names(dt_flights) %like% "^dep_"]
```

## A6 - select
Les colonnes de la table flights dont le nom finit par "_time"
```{r}
select(flights, ends_with("_time"))
dt_flights[,.SD, .SDcols = names(dt_flights) %like% "_time$"]
dt_flights[,.SD, .SDcols = grep("_time$",names(dt_flights))]
```

## A7 - select
Les colonnes de la table flights dont le nom contient "dep_"
```{r}
select(flights, contains("dep_"))
dt_flights[,.SD, .SDcols = grep("dep_", names(dt_flights))]
```

## A8 - select
Les colonnes de la table flights comprises entre "year" et "day"
```{r}
select(flights, year:day)
dt_flights[,year:day]
```

## A9 - select
Les colonnes lon et lat de la table airports renommées en longitude et latitude
```{r}
select(airports, longitude = lon, latitude = lat)
dt_airports[,.(longitude = lon, latitude = lat)]
```

## B1 - rename
Sélectionner toutes les colonnes de la table airports en renommant latitude et longitude
```{r}
rename(airports, longitude = lon, latitude = lat)
```

## B2 - rename
Créer une copie flights_fr de la table flights en renommant dep_delay en "retard départ" et arr_delay "retard arrivée" .  
```{r}
flights_fr <- rename(
    flights,
    "retard départ" = dep_delay,
    "retard arrivée" = arr_delay
)
flights_fr

dt_flights_fr <- copy(dt_flights)
setnames(dt_flights_fr, 
         c("dep_delay", "arr_delay"),
         c("retard départ","retard arrivée"))
dt_flights_fr
```

## B3 - rename
Utiliser select pour n'afficher que ces deux colonnes
```{r}
select(flights_fr, "retard départ","retard arrivée")
dt_flights_fr[, c("retard départ","retard arrivée")]
```

## B4 - rename
Idem en utilisant les back tits
```{r}
select(flights_fr, `retard départ`, `retard arrivée`)
dt_flights_fr[, .(`retard départ`,`retard arrivée`)]
```

## C1 - slice
La 345e ligne de la table airports
```{r}
slice(airports, 345)
dt_airports[345]
```

## C2 - slice
Les 5 premières lignes de la table airports

```{r}
slice(airports, 1:5)
dt_airports[1:5]
```
## C3 - slice
Les 3 dernières lignes de la table airports

```{r}
slice_tail(airports, n = 3)
dt_airports[(.N-2):.N]
```

## C4 - slice
L'aéroport avec l’altitude la plus élevée 

```{r}
slice_max(airports, alt)
dt_airports[ alt == max(alt)]
```

## C5 - slice
Les 8 vols ayant le moins de retard au départ

```{r}
slice_min(flights, dep_delay, n=8)
dt_flights[order(dep_delay)][1:8]
```

## D1 - filter
Les vols du mois de janvier
```{r}
filter(flights, month == 1)
dt_flights[month==1]
```

## D2 - filter
Les vols avec un retard au départ compris entre 10 et 15 minutes
```{r}
filter(flights, dep_delay >= 10 & dep_delay <= 15)
dt_flights[dep_delay >= 10 & dep_delay <= 15]
```

## D3 - filter
Idem en utilisant deux filtres
```{r}
filter(flights, dep_delay >= 10, dep_delay <= 15)
```

## D4 - filter
Les vols ayant une distance supérieure à la distance médiane
```{r}
filter(flights, distance > median(distance))
dt_flights[ distance > median(distance)]
```

## E1 - arrange
Trier la table flights selon le retard au départ croissant
```{r}
arrange(flights, dep_delay)
dt_flights[order(dep_delay)]
``` 

## E2 - arrange
Selon le mois, puis selon le retard au départ 
```{r}
arrange(flights, month, dep_delay)
dt_flights[order( month, dep_delay)]
``` 

## E3 - arrange
Trier la table flights selon le retard au départ décroissant
```{r}
arrange(flights, desc(dep_delay))
dt_flights[order(-dep_delay)]
``` 
## F1 - mutate
Ajouter à la table flights une nouvelle variable duree_h avec la durée de vol en heure (air_time contient la durée de vol en minutes) puis sélectionner ces deux colonnes
```{r}
flights <- mutate(flights, duree_h = air_time / 60)
select(flights, air_time, duree_h)

dt_flights[,duree_h := air_time / 60]
dt_flights[ ,.(air_time, duree_h)]

``` 

## F2 - mutate
En une seule instruction, ajouter à la table flights les variables duree_h, distance_km (= distance / 0.62137) et vitesse (en km/h), puis sélectionner ces colonnes
```{r}
flights <- mutate(
    flights,
    duree_h = air_time / 60,
    distance_km = distance / 0.62137,
    vitesse = distance_km / duree_h
)
select(flights, air_time, duree_h, distance, distance_km, vitesse)

dt_flights[ ,duree_h := air_time / 60][
  , distance_km := distance / 0.62137][
  , vitesse := distance_km / duree_h][
  , .(air_time, duree_h, distance, distance_km, vitesse)]
``` 
## F3- mutate
Ajouter à la table flights la variables type_retard en fonction du retard au départ et à l'arrivée
```{r}
flights <- mutate(
    flights,
    type_retard = case_when(
        dep_delay > 0 & arr_delay > 0 ~ "Retard départ et arrivée",
        dep_delay > 0 & arr_delay <= 0 ~ "Retard départ",
        dep_delay <= 0 & arr_delay > 0 ~ "Retard arrivée",
        TRUE ~ "Aucun retard"
    )
)
select(flights, dep_delay, arr_delay, type_retard)
``` 

## G1 - Pipe %>%
Sans utiliser le pipe, afficher par ordre croissant de retard au départ les colonnes retard au départ et retard à l'arrivée des vols ayant "LAX" pour destination
```{r}
arrange(
  select(
    filter(flights, dest == "LAX"), 
    dep_delay, arr_delay), 
  dep_delay)
``` 

## G2 - Pipe %>%
Idem en utilisant des tables temporaires
```{r}
tmp <- filter(flights, dest == "LAX")
tmp <- select(tmp, dep_delay, arr_delay)
arrange(tmp, dep_delay)
``` 

## G3 - Pipe %>%
Idem en utilisant des pipes
```{r}
flights %>%
  filter(dest == "LAX") %>%
  select(dep_delay, arr_delay) %>%
  arrange(dep_delay)

dt_flights[dest=="LAX"][
  , .(dep_delay, arr_delay)][
    order(dep_delay)]
``` 

## H1 - group_by
Afficher le premier vol de chaque mois, selon leur ordre d’apparition dans la table
```{r}
flights %>% 
  group_by(month) %>% 
  slice_head()

dt_flights[,.SD[1],by=month]
``` 

## H2 - group_by
Sélectionner, pour chaque mois de l’année, le vol ayant eu le retard au départ le plus important
```{r}
flights %>% 
  group_by(month) %>% 
  slice_max(dep_delay)

dt_flights[
  ,.SD[ dep_delay == max(dep_delay, na.rm=TRUE) ],
  keyby=month]
``` 

## H3 - group_by
Ajouter une nouvelle colonne qui contient le retard moyen au départ pour chaque compagnie aérienne
```{r}
flights %>%
  group_by(carrier) %>%
  mutate(mean_delay_carrier = mean(dep_delay, na.rm = TRUE)) %>%
  select(dep_delay, mean_delay_carrier)

dt_flights[
  ,mean_delay_carrier := mean(dep_delay, na.rm = TRUE),
  by=carrier][]
``` 

## H4 - group_by
Déterminer si un retard donné est "Supérieur" ou "Inférieur ou égal" au retard médian de la compagnie
```{r}
flights %>%
  group_by(carrier) %>%
  mutate(
      median_delay = median(dep_delay, na.rm = TRUE),
      delay_carrier = ifelse(
          dep_delay > median_delay,
          "Supérieur",
          "Inférieur ou égal"
      )
  ) %>%
  select(dep_delay, median_delay, delay_carrier)

dt_flights[
  ,median_delay := median(dep_delay, na.rm = TRUE),
  by=carrier][
    ,delay_carrier := ifelse(
          dep_delay > median_delay,
          "Supérieur",
          "Inférieur ou égal"
      )
  ][,.(dep_delay, median_delay, delay_carrier)]
``` 

## H5 - group_by
Sélectionner pour chaque mois les vols avec un retard au départ plus élevé que le retard moyen ce mois-ci
```{r}
flights %>%
  group_by(month) %>%
  filter(dep_delay >= mean(dep_delay, na.rm = TRUE))

dt_flights[
  ,.SD[dep_delay >= mean(dep_delay, na.rm = TRUE)],
  by=month]
``` 

## H6 - group_by
Grouper les vols par mois et les trier par retard au départ décroissant
```{r}
flights %>%
  group_by(month) %>%
  arrange(desc(dep_delay), .by_group = TRUE)


dt_flights[order(-dep_delay),.SD,  by=month]
``` 


## I1 - summarise et count
Calculer les retards moyens au départ et à l’arrivée pour l’ensemble des vols
```{r}
flights %>%
  summarise(
      retard_dep = mean(dep_delay, na.rm = TRUE),
      retard_arr = mean(arr_delay, na.rm = TRUE)
  )

dt_flights[,
           .(retard_dep = mean(dep_delay, na.rm = TRUE),
             retard_arr = mean(arr_delay, na.rm = TRUE))]
``` 

## I2 - summarise et count
Calculer le délai maximum, le délai minimum et le délai moyen au départ pour chaque mois
```{r}
flights %>%
  group_by(month) %>%
  summarise(
      max_delay = max(dep_delay, na.rm = TRUE),
      min_delay = min(dep_delay, na.rm = TRUE),
      mean_delay = mean(dep_delay, na.rm = TRUE)
  )

dt_flights[,
           .(max_delay = max(dep_delay, na.rm = TRUE),
             min_delay = min(dep_delay, na.rm = TRUE),
             mean_delay = mean(dep_delay, na.rm = TRUE)),
           by=month]
``` 

## I3 - summarise et count
Nombre ( n() )de vols par destination
```{r}
flights %>%
  group_by(dest) %>%
  summarise(nb = n())
``` 

## I4 - summarise et count
Nombre ( count() )de vols par destination
```{r}
flights %>%
  count(dest)
``` 

## I5 - summarise et count
Calculer le retard moyen au départ pour chaque mois et pour chaque destination, et trier le résultat par retard décroissant 
```{r}
tmp <- flights %>%
  group_by(month, dest) %>%
  summarise(retard_moyen = mean(dep_delay, na.rm = TRUE),
            .groups = "drop") %>%
  arrange(desc(retard_moyen))

dt_flights[,
           .(retard_moyen = mean(dep_delay, na.rm = TRUE)),
           by=.(month, dest)][order(-retard_moyen)]
``` 

## I6 - summarise et count
Compter le nombre de vols pour chaque couple aéroport de départ / aéroport d’arrivée, et trier le résultat par nombre de vols décroissant
```{r}
flights %>%
  count(origin, dest, sort = TRUE)

dt_flights[,.(nombre=.N), 
        by = .(origin, dest)][
          order(-nombre)]
``` 

## I7 - summarise et count
Déterminer le couple aéroport de départ / aéroport d’arrivée ayant le retard moyen au départ le plus élevé pour chaque mois de l’année
```{r}
flights %>%
  group_by(month, origin, dest) %>%
  summarise(retard_moyen = mean(dep_delay, na.rm = TRUE),
            .groups = "drop") %>%
  group_by(month) %>%
  slice_max(retard_moyen)

dt_flights[,.(retard_moyen = mean(dep_delay, na.rm = TRUE)), 
        by = .(month, origin, dest)][
          ,.SD[retard_moyen == max(retard_moyen, 
                                   na.rm = TRUE)],
          by=month]
``` 

## I8 - summarise et count
Calcule le retard moyen au départ par destination et on conserve les trois retards les plus importants pour chaque mois
```{r}
flights %>%
  group_by(month, dest) %>%
  summarise(retard_moyen = mean(dep_delay, na.rm = TRUE),
            .groups = "drop_last") %>%
  slice_max(retard_moyen, n = 3)

dt_flights[,.(retard_moyen = mean(dep_delay, na.rm = TRUE)), 
        by = .(month, dest)][
          ,.SD[order(-retard_moyen)[1:3]],
          by=month]

dt_flights[,.(retard_moyen = mean(dep_delay, na.rm = TRUE)), 
        by = .(month, dest)][
          ,head(.SD[order(-retard_moyen)], n=3),
          by=month]
``` 

## I9 - summarise et count
Les trois retards les plus importants pour l’ensemble des couples mois / destination
```{r}
flights %>%
  group_by(month, dest) %>%
  summarise(retard_moyen = mean(dep_delay, na.rm = TRUE),
            .groups = "drop") %>%
  slice_max(retard_moyen, n = 3)

dt_flights[,.(retard_moyen = mean(dep_delay, na.rm = TRUE)), 
        by = .(month, dest)][
          order(-retard_moyen)[1:3]]
``` 


## J1 - left_join
Afficher pour chaque vol son origine, sa destination et le nom complet de la compagnie aérienne

```{r}
flights %>%
  left_join( airlines, by = "carrier") %>%
  select(origin, dest, "compagnie aérienne" = name)

dt_flights[dt_airlines , on = "carrier", 
           .(origin, dest, "compagnie aérienne" = name)]
``` 


## J2 - left_join
Afficher pour chaque vol les colonnes de date et le nom complet de l'aéroport de départ

```{r}
flights %>%
  left_join( airports, by = c("origin" = "faa")) %>%
  select(year, month, day, "aéroport de départ" = name)

dt_flights[ dt_airports, on = .(origin = faa ), nomatch = NULL,
           .(year, month, day, "aéroport de départ" = name)]

dt_airports[ dt_flights, on = c( "faa" = "origin"),
           .(year, month, day, "aéroport de départ" = name)]
``` 

## J3 - left_join
Afficher pour chaque vol le nom complet de l'aéroport de départ et de l'aéroport d'arrivée

```{r}
flights %>%
  left_join( airports, by = c("origin" = "faa")) %>%
  left_join( airports, by = c("dest" = "faa"),
    suffix = c("_depart", "_arrivee")) %>%
  select("aéroport de départ" = name_depart, 
         "aéroport d'arrivée" = name_arrivee)

dt_airports[ 
  dt_airports[ 
    dt_flights, on = .(faa = origin)],
  on = .(faa=dest),
.(year, month, day,
  "aéroport de départ" = i.name,
  "aéroport d'arrivee" = name)]
``` 


## J4 - left_join
Afficher pour chaque vol le nom complet de l'aéroport de départ, celui de l'aéroport d'arrivée et celui de la compagbnie aérienne

```{r}
flights %>%
  left_join( airports, by = c("origin" = "faa")) %>%
  left_join( airports, by = c("dest" = "faa"),
    suffix = c("_depart", "_arrivee")) %>%
  left_join( airlines, by = "carrier") %>%
  select("aéroport de départ" = name_depart, 
         "aéroport d'arrivée" = name_arrivee,
         "compagnie aérienne" = name)

dt_airlines[ 
  dt_airports[ 
    dt_airports[ 
      dt_flights, on = .(faa = origin)],
    on = .(faa=dest)],
  on= "carrier"][, 
  .(year, month, day,
    "aéroport de départ" = i.name.1,
    "aéroport d'arrivee" = i.name,
    "compagnie aérienne" = name)]

``` 

## J5 - left_join
Carte des aéroports de destination avec le nombre de vols
```{r}
library(leaflet)
flights %>%
  count(dest) %>%
  left_join(airports, by = c("dest" = "faa")) %>%
  leaflet %>%
  addTiles %>%
  addCircles(lng = ~lon, lat = ~lat, 
             radius = ~n * 10, 
             popup = ~paste(name, n, sep = " : "))
```


# Exercices ggplot2

```{r echo = TRUE}
library(dplyr)
library(ggplot2)
```

## Data
```{r echo = TRUE}
library(questionr)
data(rp2018)

rp <- rp2018 %>% 
  filter( departement %in% 
            c("Oise", "Rhône", "Hauts-de-Seine", 
              "Lozère", "Bouches-du-Rhône"))
```

## K1 - geom_histogram
Distribution des communes de la table rp selon le pourcentage de cadres dans leur population active (variable cadres)
```{r message=FALSE}
ggplot(rp) +
    geom_histogram(aes(x = cadres))
```

## K2 - geom_histogram
Distribution en 10 tranches des communes de la table rp selon le pourcentage d'ouvriers 
```{r}
ggplot(rp) +
    geom_histogram(aes(x = ouvr), bins = 10)
```

## K3 - geom_histogram
Distribution en tranches de 5% des communes de la table rp selon le pourcentage d'étudiants 
```{r}
ggplot(rp) +
    geom_histogram(aes(x = etud), binwidth = 5)
```

## L1 - geom_point
Nuage de points du pourcentage de cadres en fonction du pourcentage de diplomes supérieurs (dipl_sup)
```{r}
ggplot(rp) +
    geom_point(aes(x = dipl_sup, y = cadres))
```

## L2 - geom_point
Idem avec les paramètres couleur = "darkgreen", taille = 3 et transparence = 0.3
```{r}
ggplot(rp) +
    geom_point(aes(x = dipl_sup, y = cadres),
               color = "darkgreen", size = 3, alpha = 0.3)
```

## M1 - geom_boxplot
Boite à moustache de répartition du pourcentage de maisons en fonction du département de la commune
```{r}
ggplot(rp) +
    geom_boxplot(aes(x = departement, y = maison))
```

## M2 - geom_boxplot
Idem en faisant varier la largeur des boîtes en fonction des effectifs de la classe
```{r}
ggplot(rp) +
    geom_boxplot(aes(x = departement, y = maison), varwidth = TRUE)
```

## N1 - geom_violin
Idem en utilisant des graphes en violon à la place des boîtes à moustache
```{r}
ggplot(rp) +
    geom_violin(aes(x = departement, y = maison))
```

## N2 - geom_violin
Idem en mettant à l'échelle en fonction du nombre de commune
```{r}
ggplot(rp) +
    geom_violin(aes(x = departement, y = maison), scale = "count")
```

## N3 - geom_boxplot
Idem en faisant varier le niveau de “détail” de la représentation en utilisant l’argument bande passante = 2
```{r}
ggplot(rp) +
    geom_violin(
        aes(x = departement, y = maison),
        bw = 2
    )
```

## O1 - geom_bar et geom_col
Graphique en bâtons du nombre de communes pour chaque département
```{r}
ggplot(rp) +
    geom_bar(aes(x = departement))
```

## O2 - geom_bar et geom_col
Graphique en barres horizontales en utilisant y au lieu de x
```{r}
ggplot(rp) +
    geom_bar(aes(y = departement))
```

## O3 - geom_bar et geom_col
Idem en utilisant y au lieu de x
```{r}
ggplot(rp) +
    geom_bar(aes(y = departement))
```

## O4 - geom_bar et geom_col
Idem en utilisant coord_flip()
```{r}
ggplot(rp) +
    geom_bar(aes(x = departement)) +
    coord_flip()
```

## O5 - geom_bar et geom_col
Calculer le nombre de commune par département puis afficher les résultats avec geom_col()
```{r}
rp %>%
  count(departement) %>%
  ggplot() +
    geom_col(aes(x = departement, y = n))
```

## O6 - geom_bar et geom_col
Idem en changeant la couleur de remplissage = "darkblue" et la largeur des barres à 50%
```{r}
rp %>%
  count(departement) %>%
  ggplot() +
    geom_col(aes(x = departement, y = n),
        fill = "darkblue", width = .5)
```

## P1 - geom_text et geom_label
Nuage croisant la part des diplômés du supérieur et la part de cadres, mais en affichant le nom de la commune plutôt qu’un simple point
```{r}
ggplot(rp) +
    geom_text(aes(x = dipl_sup, y = cadres, label = commune))
```

## P2 - geom_text et geom_label
Idem en changeant les paramètres couleur = "darkred" et taille = 2
```{r}
ggplot(rp) +
    geom_text(
        aes(x = dipl_sup, y = cadres, label = commune),
        color = "darkred", size = 2
    )
```

## P3 - geom_text et geom_label
Idem en utilisant geom_label
```{r}
ggplot(rp) +
    geom_label(
        aes(x = dipl_sup, y = cadres, label = commune),
        color = "darkred", size = 2
    )
```

## Q1 - geom_density
Densité de la répartition de la part des cadres dans les communes
```{r}
ggplot(rp) +
    geom_density(aes(x = cadres))
```

## Q2 - geom_density
Idem en faisant varier le niveau de “détail” de la représentation en utilisant l’argument bande passante = 2
```{r}
ggplot(rp) +
    geom_density(aes(x = cadres), bw=2)
```

## R1 - Mappages
Nuage de points du pourcentage de cadres en fonction du pourcentage de diplôme supérieur en colorant par département
```{r}
ggplot(rp) +
    geom_point(
        aes(x = dipl_sup, y = cadres, color = departement)
    )
```

## R2 - Mappages
Idem avec la taille des points représentant la population totale
```{r}
ggplot(rp) +
    geom_point(
        aes(x = dipl_sup, y = cadres, 
            color = departement, size = pop_tot)
    )
```

## R3 - Mappages
Idem en faisant varier la transparence des points en fonction du nombre de maisons
```{r}
ggplot(rp) +
    geom_point(
        aes(x = dipl_sup, y = cadres, 
            color = departement, size = pop_tot, alpha = maison)
    )
```

## R4 - Mappages
Graphique à barres empilées du nombre de communes par classe de population pour chaque département
```{r}
ggplot(rp) +
  geom_bar(aes(x = departement, fill = pop_cl))
```

## R5 - Mappages
Graphique à barres groupées du nombre de communes par classe de population pour chaque département
```{r}
ggplot(rp) +
  geom_bar(aes(x = departement, fill = pop_cl),
           position = "dodge")
```

## R6 - Mappages
Graphique à barres empilées de la proportion de communes par classe de population pour chaque département
```{r}
ggplot(rp) +
  geom_bar(aes(x = departement, fill = pop_cl),
           position = "fill")
```

## R7 - Mappages
Idem avec un graphique à barre horizontales
```{r}
ggplot(rp) +
  geom_bar(aes(x = departement, fill = pop_cl),
           position = "fill") +
  coord_flip()
```

## S1 - Plusieurs geom
Boîte à moustache de la répartition du pourcentage de maisons des communes pour chaque département avec un point rouge et transparent de 20% pour chaque commune
```{r}
ggplot(rp) +
    geom_boxplot(aes(x = departement, y = maison)) +
    geom_point(
        aes(x = departement, y = maison),
        col = "red", alpha = 0.2
    )
```

## S2 - Plusieurs geom
Idem en utilisant geom_jitter pour limiter les superpositions
```{r}
ggplot(rp) +
    geom_boxplot(aes(x = departement, y = maison)) +
    geom_jitter(
        aes(x = departement, y = maison),
        col = "red", alpha = 0.2
    )
```

## S3 - Plusieurs geom
Idem en regroupant les mappages communs dans l'appel à ggplot()
```{r}
ggplot(rp,aes(x = departement, y = maison)) +
    geom_boxplot() +
    geom_jitter(col = "red", alpha = 0.2)
```

## S4 - Plusieurs geom
Nuage de points des pourcentages de cadres par pourcentage de diplômes supérieurs avec une ligne de régression linéaire en utilisant geom_smooth
```{r}
ggplot(rp, aes(x = dipl_sup, y = cadres)) +
    geom_point(alpha = 0.2) +
    geom_smooth(method = "lm")
```

## S5 - Plusieurs geom
Idem en ajoutant les courbes de densité avec geom_density2d
```{r}
ggplot(rp, aes(x = dipl_sup, y = cadres)) +
    geom_point(alpha = 0.2) +
    geom_density2d(color = "red")+
    geom_smooth(method = "lm") 
```

## S6 - Plusieurs geom
Graphique à colonne représentant le nombre de commune par département, avec la valeur affichée au dessus des colonnes 
```{r}
rp %>%
  count(departement) %>%
  ggplot(aes(x = departement, y = n)) +
    geom_col() +
    geom_text(aes(y = n+10, label = n))
```


## T1 - Plusieurs sources de données
Idem en affichant les noms de communes de + de 50 000 habitants. (Commencer par créer un data.frame contenant uniquement ces communes)
```{r}
com50 <- rp %>%
  filter(pop_tot >= 50000)

rp %>% 
  ggplot( aes(x = dipl_sup, y = cadres)) +
    geom_point(alpha = 0.2) +
    geom_text(
        data = com50, aes(label = commune),
        color = "red", size = 3
    )
```

## U1 - Le faceting
Faire un histogramme de la distribution des pourcentages de cadres pour chacun des départements et les afficher avec facet_wrap
```{r}
rp %>% 
  ggplot() +
    geom_histogram(aes(x = cadres), bins = 30) +
    facet_wrap(vars(departement))
```

## U2 - Le faceting
Idem avec un affichage en lignes
```{r}
rp %>% 
  ggplot() +
    geom_histogram(aes(x = cadres), bins = 30) +
    facet_grid(rows = vars(departement))
```

## U3 - Le faceting
Idem en ajoutant des colonnes pour les classes de population
```{r}
ggplot(data = rp) +
    geom_histogram(aes(x = cadres), bins = 30) +
    facet_grid(
        rows = vars(departement), 
        cols = vars(pop_cl)
    )
```

## V1 - scale_size
Nuage de points des pourcentages de cadres en fonction des pourcentages de diplômes supérieurs en répartissant la taille des points entre 0 et 20
```{r}
ggplot(rp) +
    geom_point(aes(x = dipl_sup, y = cadres, size = pop_tot)) +
    scale_size(range = c(0, 20))
```

## V2 - scale_size
Idem en répartissant la taille des points entre 0 et 15 et en renommant la légende "Population"
```{r}
ggplot(rp) +
    geom_point(aes(x = dipl_sup, y = cadres, size = pop_tot)) +
    scale_size(
        "Population",
        range = c(0, 15)
    )
```

## V3 - scale_size
Idem en spécifiant les valeurs à représenter dans la légende
```{r}
ggplot(rp) +
    geom_point(aes(x = dipl_sup, y = cadres, size = pop_tot)) +
    scale_size(
        "Population",
        range = c(0, 15),
        breaks = c( 5000, 10000, 50000)
    )
```

## W1 - scale_x, scale_y
Nuage de points des pourcentages de cadres en fonction des pourcentages de diplômes supérieurs en étendant les axes jusqu'à 100%
```{r}
ggplot(rp) +
    geom_point(aes(x = dipl_sup, y = cadres)) +
    scale_x_continuous(limits = c(0, 100)) +
    scale_y_continuous(limits = c(0, 100))
```

## W2 - scale_x, scale_y
Idem en renommant les axes
```{r}
ggplot(rp) +
    geom_point(aes(x = dipl_sup, y = cadres)) +
    scale_x_continuous("Part des diplômés du supérieur (%)", 
                       limits = c(0, 100)) +
    scale_y_continuous("Part des cadres (%)", 
                       limits = c(0, 100))
```

## W3 - scale_x, scale_y
Idem en appliquant une échelle logarithmique sur les diplômes
```{r}
ggplot(rp) +
    geom_point(aes(x = dipl_sup, y = cadres)) +
    scale_x_log10("Diplômés du supérieur")
```

## W4 - scale_x, scale_y
Nombre de commune de chaque département en renommant l'axe de x "Département"
```{r}
ggplot(rp) +
    geom_bar(aes(x = departement)) +
    scale_x_discrete("Département") +
    scale_y_continuous("Nombre")
```

## W5 - scale_x, scale_y
Idem en limitant aux départements "Oise", "Lozère" et "Rhône"
```{r warning=FALSE}
  ggplot(rp) +
    geom_bar(aes(x = departement)) +
    scale_x_discrete("Département", 
                     limits = c("Oise", "Lozère", "Rhône"))
```

## X1 - scale_color, scale_fill
Nuage de points des pourcentages de cadres en fonction des pourcentages de diplômes supérieurs en colorant les points part la part de chômeurs
```{r}
ggplot(rp) +
    geom_point(aes(x = dipl_sup, y = cadres, color = chom))
```

## X2 - scale_color, scale_fill
Idem en spécifiant un gradient de blanc à rouge
```{r}
ggplot(rp) +
    geom_point(aes(x = dipl_sup, y = cadres, color = chom)) +
    scale_color_gradient("Taux de chômage", low = "white", high = "red")
```

## X3 - scale_color, scale_fill
Idem en spécifiant la palette plasma de l'échelle de couleur viridis
```{r}
ggplot(rp) +
    geom_point(aes(x = dipl_sup, y = cadres, color = chom)) +
    scale_color_viridis_c("Taux de chômage", option = "plasma")
```

## X4 - scale_color, scale_fill
Idem en colorant cette fois par département avec la palette manuelle : "red", "#FFDD45", rgb(0.1, 0.2, 0.6), "darkgreen" et "grey80"
```{r}
ggplot(rp) +
    geom_point(aes(x = dipl_sup, y = cadres, color = departement)) +
    scale_color_manual(
        "Département",
        values = c("red", "#FFDD45", rgb(0.1, 0.2, 0.6), 
                   "darkgreen", "grey80")
    )
```

## X4 - scale_color, scale_fill
Idem en utilisant la palette "Set1" de scale_color_brewer
```{r}
ggplot(rp) +
    geom_point(aes(x = dipl_sup, y = cadres, color = departement)) +
    scale_color_brewer("Département", palette = "Set1")
```

## Data avec des séries temporelles
```{r}
data("economics")
economics
```

## Y1 - geom_line
Evolution dans le temps du nombre de chômeurs aux États-Unis 
```{r}
ggplot(economics) +
    geom_line(aes(x = date, y = unemploy))
```

## Z1 - Thèmes
Idem en utilisant le thème noir et blanc
```{r}
ggplot(economics) +
    geom_line(aes(x = date, y = unemploy))+
    theme_bw()
```

## Z2 - Thèmes
Idem en utilisant le thème minimal
```{r}
ggplot(economics) +
    geom_line(aes(x = date, y = unemploy))+
    theme_minimal()
```

## Z3 - Thèmes
Idem en donnant un titre au graphique, en renommant l'axe des y et supprimant le titre de l'axe des x
```{r}
ggplot(economics) +
    geom_line(aes(x = date, y = unemploy)) +
    ggtitle("Evolution du chômage mensuel aux USA") +
    xlab(NULL) +
    ylab("Chômeurs (en milliers)")
```

